import time
import dateparser
import pytz
from datetime import datetime
import urllib3
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import math

def sma(a, n=3) :
    """Calcula la media movil
    Recibe una lista a y n periodos
    Devuelve el vector incompleto con la misma cantidad miembros"""
    ret = np.cumsum(a, dtype=float)
    ret[n:] = ret[n:] - ret[:-n]
    b = np.repeat(None, (n - 1))
    return np.concatenate((b,ret[n - 1:] / n))


def ema(s, n):
    """Calcula la media movil exponencial
    Recibe una lista a y n periodos
    Devuelve el vector incompleto con la misma cantidad miembros"""
    ema = []
    j = 1
    #get n sma first and calculate the next n period ema
    sma = sum(s[:n]) / n
    multiplier = 2 / float(1 + n)
    ema.append(sma)
    #EMA(current) = ( (Price(current) - EMA(prev) ) x Multiplier) + EMA(prev)
    ema.append(( (s[n] - sma) * multiplier) + sma)
    #now calculate the rest of the values
    for i in s[n+1:]:
        tmp = ( (i - ema[j]) * multiplier) + ema[j]
        j = j + 1
        ema.append(tmp)
    b = []
    b = np.repeat(None, (n-1))
    return np.concatenate((b,ema), axis=None)


def emawonone(s, n):
    """Calcula la media movil exponencial
    Recibe una lista a y n periodos
    Devuelve el vector completo con la misma cantidad miembros"""
    ema = []
    j = 1
    #get n sma first and calculate the next n period ema
    sma = sum(s[:n]) / n
    multiplier = 2 / float(1 + n)
    ema.append(sma)
    #EMA(current) = ( (Price(current) - EMA(prev) ) x Multiplier) + EMA(prev)
    ema.append(( (s[n] - sma) * multiplier) + sma)
    #now calculate the rest of the values
    for i in s[n+1:]:
        tmp = ( (i - ema[j]) * multiplier) + ema[j]
        j = j + 1
        ema.append(tmp)
    b = []    
    return np.concatenate((b,ema), axis=None)
    
    
def exponentialmovingaverage(price, time, amq, amm, ams):
    lastvalue = len(price) - 1
    AMquick = ema(price, amq)
    AMmedium = ema(price, amm)
    AMslow = ema(price, ams)
    x = np.asarray(time)
    graphicator(x, price, AMslow, AMmedium, AMquick)  
    
    if (AMquick[lastvalue] > AMslow[lastvalue]):
        status = True
    else:
        status = False
    return status
        

def macd(price, time):
    
    #Creacion de las variables iniciales
    lastvalue = len(price) - 1
    PMEs = ema( price, 12)
    PMEq = ema( price, 26)
    MACD0 = []
    MACD1 = []
    Histograme = []
    zero = np.zeros(len(price))
    #Calculamos el MACD
    for i in range(len(price)):
        if i < 26:
            MACD0.append(None)
        elif i >= 26:
            result = PMEs[i] - PMEq[i] 
            MACD1.append(result)
    #Calculamos la signal     
    signal0 = ema(MACD1, 9)
    #Ordenamos MACD y Signal
    signal = np.concatenate((MACD0,signal0), axis=None)
    MACD = np.concatenate((MACD0,MACD1), axis=None)
    #Calculamos el histograma
    for i in range(len(price)):
        if (MACD[i]== None or signal[i]== None):
            Histograme.append(None)
        else:
            result = MACD[i] - signal[i] 
            Histograme.append(result)

    x = np.asarray(time)
    graphicator(x, MACD, signal, Histograme, zero)  
    if (MACD[lastvalue] > signal[lastvalue]):
        status = True
    else:
        status = False
    return status




def emv(Highprice,Lowprice,Volume, Timestampop, divider = 10000, movingaverage = 14, judge = 0.4 ):
    """Ease of movement (EMV) is an indicator used in technical analysis to relate an asset's 
    price change to its volume. Ease of Movement was developed by Richard W. Arms, Jr. and 
    highlights the relationship between volume and price changes and is particularly useful 
    for assessing the strength of a trend. High positive values indicate the price is increasing 
    on low volume: strong negative values indicate the price is dropping on low volume. 
    The moving average of the indicator can be added to act as a trigger line, 
    which is similar to other indicators like the MACD.
    Input data:
        Highprice
        Lowprice
        Volume
        Timestampop
        divider
        movingaverage
        judge: judge manual
    
    """
 
    
    size = len(Highprice)
    distance = []
    box = []
    emv = []
    smaEMV0 = []
    smaEMV1 = []
    smaEMV = []
    lineup = []
    linedown = []
    
    for i in range(size):
        distance.append(((Highprice[i]+Lowprice[i])/2)-((Highprice[i-1]+Lowprice[i-1])/2))
        try: 
            box.append((Volume[i]/divider)/ ((Highprice[i]-Lowprice[i])))
            emv.append(-(1-(distance[i]/box[i])))
        except ZeroDivisionError:
            return emv.append(0)
    emv.pop(0)
    smaEMV0 = sma(emv, movingaverage)
    smaEMV1 = smawonone(emv, movingaverage)
    
    
    # Start bandas discriminadoras
    MAX = max(smaEMV1)    
    MIN = min(smaEMV1)    
    total = MAX - MIN
    parte = total/2
    margin = parte*judge
    limitUP = MAX - margin
    limitDN = MIN + margin
    
    lineup = createline( limitUP, len(emv)+1)
    linedown = createline( limitDN, len(emv)+1)
    #End Bandas
    
    
    Timestampop
    x = np.asarray(Timestampop)
    
    
    if (limitUP >= smaEMV0[-1]) or (limitDN <= smaEMV0[-1]) :
        status = False
    else:
        status = True
        
    
    smaEMV = smaEMV0.tolist()
    smaEMV.append(None)
    
    
    return status, [x, smaEMV, smaEMV, lineup, linedown ]

